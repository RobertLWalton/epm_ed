% File:		vec-2d.tex
% Author:	See Below
% Date:	        See Below
%
% The authors have placed this file in the public domain;
% they make no warranty and accept no liability for this file.

\documentclass[12pt]{article}
\usepackage{times}
\usepackage{color}
\usepackage[usenames]{xcolor}
\usepackage{scalefnt}
\usepackage{tikz}
\usepackage{wrapfig}
\usetikzlibrary{arrows}
\begin{document}
\newcommand{\header}[1]{\underline{\bf #1}}
\newcommand{\file}[1]{{\bf #1}}
\newcommand{\blankpage}{\newpage\vspace*{3.5in}%
    \centerline{\Large This Page is Intentionally Left Blank}}
\setlength{\parindent}{0.0in}
\setlength{\parskip}{1ex}
\newcommand{\key}[1]{{\bf #1}}
\newcommand{\TT}[1]{{\tt \bfseries #1}}
\newcommand{\EOL}{\penalty \exhyphenpenalty}
\newtheorem{definition}{Definition}[section]
\newtheorem{lemma}{Lemma}[section]
\newenvironment{indpar}[1]%
    {\begin{list}{}{\setlength{\leftmargin}{#1}}\item[]}%
    {\end{list}}

\section{Two Dimensional Vector Calculator}
This document describes a group of problems involving 2-dimensional vectors,
starting with simple vector calculations, and working up to polygons.
The problems are embedded in a simple calculator for ease of
testing.

\section{Boolean, Scalars, Vectors, and Transforms}
A \key{boolean} here is either the symbol \key{true} or the symbol \key{false}.

A \key{scalar} here is a double precision floating point number.

A \key{vector} here is a pair $(x,y)$ of double precision floating point
numbers, $x$ denoting an X-coordinate value, and $y$ denoting a
Y-coordinate value.  Such a vector can denote a point $(p_x,p_y)$ in the
XY-plane, or can denote a translation $v$ of the plane:
\centerline{$(p_x,p_y) \longmapsto (p_x+v_x,p_y+v_y)$}

The product of a scalar $s$ and a vector $v=(v_x,v_y)$ is represented using
$*$ as $s*v == (sv_x,sv_y)$.

A \key{linear transformation} here is a pair of vectors, $(\ell_x,\ell_y)$
representing the map:
\centerline{$(v_x,v_y) \longmapsto v_x*\ell_x+v_y*\ell_y$}
Application is represented using
$*$ as $(\ell_x,\ell_y)*v=v_x*\ell_x+v_y*\ell_y$.

An \key{affine transformation} here is a triple of vectors,
$(\ell_x,\ell_y,\tau)$
representing: \\
\centerline{$(v_x,v_y) \longmapsto v_x*\ell_x+v_y*\ell_y+\tau$}
Application is represented using
$*$ as $(\ell_x,\ell_y,\tau)*v=v_x*\ell_x+v_y*\ell_y+\tau$. \\
(An affine transformation is a linear transformation followed by
a translation.)

\newpage

\section{The Calculator Language}
The calculator language of this problem is very simple.
An example is:
\\[1ex]
{\tt
\hspace*{0.2in}\begin{tabular}{l@{\hspace{0.5in}}l}
\rm \bf Input	& \rm \bf Output \\\hline
x=4		& x=4 \\
y = 0.5         & y = 0.5 \\
z = x + y       & z = x + y = 4.5 \\
v=(3,-2)	& v=(3,-2) \\
w=z*v		& w=z*v = (13.5,-9) \\
\# this is a comment & \# this is a comment
\end{tabular}
} % \tt

The syntax is:
\\[1ex]
\hspace*{0.2in}\begin{tabular}{l}
{\em program} ::= {\em statement}$^\star$ \\
{\em statement} ::= \\
\hspace*{0.2in}\begin{tabular}[t]{cl}
                    & {\em comment} \\
                $|$ & {\em variable} \TT{=} {\em value} {\em eol}\\
                $|$ & {\em variable} \TT{=} {\em operator}
		          {\em variable} 
		          {\em operator}$^?$ {\em eol} \\
                $|$ & {\em variable} \TT{=} {\em variable} {\em operator}
		          {\em variable}
		          \{ {\em operator} {\em variable} \}$^?$
			  {\em eol} \\
                $|$ & {\em variable} \TT{=} {\em function}
		          {\em variable}$^\star$ {\em eol} \\
		\end{tabular}
\\[1ex]
{\em eol} ::= end-of-line (line-feed) \\
{\em comment} ::= \TT{\#} {\em character-other-than-line-feed}$^\star$
                  {\em eol} \\
{\em variable} ::= a single letter (case matters) \\
{\em value} \begin{tabular}[t]{cl}
            ::= & {\em boolean} $|$ {\em scalar} $|$ {\em vector} \\
	    $|$ & {\em linear-transform} $|$
	          {\em affine-transform} \\
	    \end{tabular} \\
{\em boolean} ::= \TT{true} $|$ \TT{false} \\
{\em scalar} ::= double precision floating point number (e.g., 1.4142135) \\
{\em vector} ::= \TT{(} {\em scalar}\TT{,} {\em scalar} \TT{)} \\
{\em linear-transform} ::= \TT{(} {\em vector}\TT{,} {\em vector} \TT{)} \\
{\em affine-transform} ::= \TT{(} {\em vector}\TT{,} {\em vector}\TT{,}
                                  {\em vector} \TT{)} \\
{\em operator} ::= one or more non-letter graphic characters
                   (e.g. {\tt +} or {\tt <=})\\
{\em function} ::= three or more letters (e.g. {\tt sin} or {\tt length}) \\
\end{tabular}

\begin{center}
Whitespace in {\em statements} is optional \\
and is deleted before the {\em statements} are parsed.
\\[1ex]
The output of a {\em statement} is a copy of the {\em statement}, \\
which if the {\em statement} has an {\em operator} or {\em function} \\
is followed by `{\em space} \TT{=} {\em space} {\em value}'.
\end{center}

\newpage

\section{Scalar Calculator}
Implement the calculator with just {\em scalar} and {\em boolean}
value types and the 
{\em operators} and {\em functions}:
\begin{center}
\begin{tabular}{l@{~~~~~}l}
Assume:	& {\tt x=}$x$, {\tt y=}$y$ (scalars) \\
	& {\tt d=}$d$ (an integer scalar $\ge 0$) \\
	& {\tt b=}$b$ (a boolean) \\
then: \\[1ex]
\tt x+y & returns $x + y$ \\
\tt x-y & returns $x - y$ \\
\tt x*y & returns $x \times y$ \\
\tt x/y & returns $x / y$ \\
\tt x\%y & returns $x~\mathrm{modulo}~y$ \\
\tt cos x & returns $\cos ( \pi/180 * x )$ \\
\tt sin x & returns $\sin ( \pi/180 * x )$ \\
\tt tan x & returns $\tan ( \pi/180 * x )$ \\
\tt x<y & returns \TT{true} if $x<y$, else \TT{false} \\
\tt x<=y & returns \TT{true} if $x\le y$, else \TT{false} \\
\tt x==y:d & returns \TT{true} if $|x-y|<0.5*10^{-d}$, else \TT{false} \\
           & (means $x$ = $y$ assuming both really have exactly $d$
	      decimal places \\
	   & ~but have only been calculated to within $d+1$ decimal places) \\
\tt x>y & returns \TT{true} if $x>y$, else \TT{false} \\
\tt x>=y & returns \TT{true} if $x\ge y$, else \TT{false} \\
\tt -x & returns $-x$ \\
\tt |x| & returns $|x|$, the absolute value of $x$ \\
\tt b?x:y & returns $x$ if $b$ is \TT{true} else returns $y$ \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{rl}
Sample Input File: & \file{00-scalar-vec-2d.sin} \\
Sample Output File: & \file{00-scalar-vec-2d.sout} \\
or: & \file{00-scalar-vec-2d.ftest} \\
Submit Run File: & \file{submit-scalar-vec-2d.run} \\
\end{tabular}
\end{center}

Note that the {\tt .ftest} files for this problem are identical
to the corresponding {\tt .sout} files.

You can test your program using the indicated sample input and
output and you can submit your program using the indicated submit
run file.  Only scalar functionality is tested.

\subsection{Scalar Coding Hints}
The calculator memory just maps each variable to a value.
You can map each ASCII character to a value using a
vector of 128 elements, and simply not use the elements
that do not correspond to letters.

To parse a non-comment, remove its whitespace characters
and look at the two characters following {\tt =}.  If they
are both letters, they are part of a {\em function} or {\em boolean}.
If one is a digit or `{\tt (}', they are part of a {\em value}.  
If only one is a letter, any letters are {\em variables}
and the non-letters are in {\em operators}.

The following data structure definitions may be helpful.
Also, using these definitions may make it easier
for other people familiar with this problem to read your
code, should that be important.

\hspace*{0.3in}\begin{minipage}{5.0in}
\begin{verbatim}
/* C Data Structures
 */
# include <math.h>    /* PI is M_PI */
typedef struct { double x, y; } vec;
typedef struct { vec lx, ly; } linear;
typedef struct { vec lx, ly, tau; } affine;
enum boolean { TRUE = 1, FALSE = 0 };
enum type { NONE = 0, BOOLEAN, SCALAR, VECTOR,
                      LINEAR, AFFINE };
typedef struct {
    type t;
    boolean b;
    scalar s;
    vector v;
    linear l;
    affine a;
} var;
\end{verbatim}
\end{minipage}

\bigskip

\hspace*{0.3in}\begin{minipage}{5.0in}
\begin{verbatim}
// C++ Data Structures
//
# include <cmath>    // PI is M_PI
struct vec { double x, y; };
struct linear { vec lx, ly; };
struct affine { vec lx, ly, tau; };
enum boolean { TRUE = 1, FALSE = 0 };
enum type { NONE = 0, BOOLEAN, SCALAR, VECTOR,
            LINEAR, AFFINE };
struct var {
    type t;
    boolean b;
    scalar s;
    vector v;
    linear l;
    affine a;
};
\end{verbatim}
\end{minipage}

\section{Operations on Vectors}
\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}{r}{0.45\textwidth}
\begin{tikzpicture}[x=0.25in,y=0.25in]
\begin{scope}[>=triangle 45,shorten >=0.01in]

    \fill[black] (0,0) circle(0.1) + (+0.0,-0.5) node[black]{$p$};

    \draw[red,->] (0,0) -- (+3,+1);
    \draw[black] (1.3,0.8) node{$v$};
    \fill[black] (+3,+1) circle(0.1) + (+0.2,-0.5) node[black]{$p+v$};
    \draw[blue,->] (+3,+1) -- (-1,+4);
    \draw[black] (+1.6,2.5) node{$w$};
    \fill[black] (-1,+4) circle(0.1) + (+0.5,+0.5) node[black]{$p+v+w$};

    \draw[blue,->] (0,0) -- (-4,+3);
    \draw[black] (-2.8,1.4) node{$w$};
    \fill[black] (-4,+3) circle(0.1) + (-0.2,+0.5) node[black]{$p+w$};
    \draw[red,->] (-4,+3) -- (-1,+4);
    \draw[black] (-2.1,3.3) node{$v$};

    \draw[brown,->] (0,0) -- (-1,+4);
    \draw[black] (-0.2,1.8) node{$v+w$};
\end{scope}
\end{tikzpicture}
\end{wrapfigure}
We will define the \key{vector sum} of vectors $v=(v_x,v_y)$ and
$w=(w_x,w_y)$ to be $v+w=(v_x+w_x,v_y+w_y)$.  If you
think of a point $p=(p_x,p_y)$ in the XY-plane as a vector,
you can associate a translation $\tau_v$ of the XY-plane
with the vector $v$ using the equation $\tau_v(p)=p+v$.  Then\\
\hspace*{0.2in}$\tau_w(\tau_v(p)) = p+v+w = \tau_{v+w}(p)$ \\
See the picture.
\\[1ex]
Note that vector sums are commutative, i.e.,  $v+w=w+v$, and associative,
i.e., $u+(v+w)=(u+v)+w$.
\end{minipage}

\bigskip

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}{r}{0.55\textwidth}
\begin{tikzpicture}[x=0.20in,y=0.20in]
\begin{scope}[>=triangle 45]

    \draw[black,->] (0,3) -- (4,3) node[black,right]{$2*v$};
    \draw[black,->] (0,2) -- (2,2) node[black,right]{$v$};
    \draw[black,->] (0,1) -- (1,1) node[black,right]{$0.5*v$};
    \fill[black] (0,0) circle(0.1) node[black,right]{$0*v$}; 
    \draw[red,->] (0,-1) -- (-1,-1) node[black,left]{$-0.5*v$};
    \draw[red,->] (0,-2) -- (-2,-2) node[black,left]{$-1.0*v$};
    \draw[red,->] (0,-3) -- (-4,-3) node[black,left]{$-2.0*v$};
\end{scope}
\end{tikzpicture}
\end{wrapfigure}
We define the \key{scalar product} of a scalar $s$ and a vector
$v=(v_x,v_y)$ as $s*v = (s*v_x,s*v,y)$.  Multiplication
of $v$ by $s>0$ does not change the direction of $v$,
but multiplies the length of $v$ by $s$.  Multiplication of $v$ by
$s<0$ reverses the direction of $v$ and multiplies its length
by $|s|$.  See the picture.
\\[1ex]
Note that scalar products are associative in the sense that
$s_1*(s_2*v)=(s_1*s_2)*v$.
\end{minipage}

\bigskip

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}{r}{0.4\textwidth}
\begin{tikzpicture}[x=0.20in,y=0.20in]
\begin{scope}[>=triangle 45,shorten >=0.01in]
    \draw[black] (-1,0) -- (+5,0);
    \draw[black] (0,-1) -- (0,+3);

    \fill[red] (0,0) circle(0.1);
    \draw[black] (2.0,-0.5) node{$||v||*\cos \theta$};

    \draw[brown,>=latex,->] (2.0,0) arc(0:30:2.0);
    \draw[black] (2.4,+0.4) node{$\theta$};

    \fill[red] (3.464101615,2.0) circle(0.1);
    \draw[red,->] (0,0) -- (3.464101615,2.0);
    \draw[black] (1.3,+1.5) node{$||v||$};

    \draw[orange] (3.464101615,0) -- (3.464101615,2.0);
    \draw[black] (3.464101615,1) + (0.1,0)
                 node[right]{$||v||*\sin \theta$};
\end{scope}
\end{tikzpicture}
\end{wrapfigure}
A vector $v=(v_x,v_y)$ has a length and a direction.
The \key{length}, denoted by $||v||$, can be computed using
Pythagoras's Theorm: $||v||=\sqrt{v_x^2+v_y^2}$.  The
direction is given by the counterclockwise angle $\theta$ from
the positive X-axis direction to the vector direction.
This is called the \key{azimuth} of $v$, and in computer
languages may be computed (in radians) by the {\tt atan2} function as
$\theta = \mathrm{atan2}(v_y,v_x)$ (note $v_y$ comes before $v_x$).
\\[1ex]
The vector with length $\ell$ and azimuth $\theta$ is
$(\ell \cos\theta,\ell \sin\theta)$.
See the picture.
\\[1ex]
Note that adding integer multiples of 360 to a vector's
azimuth does \underline{not} change the vector.
\end{minipage}

\newpage

\section{Vector Calculator}
Implement additions to the basic calculator for just {\em vector}
value types and the {\em operators} and {\em functions}:
\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}
Assume: & {\tt s=}$s$, {\tt x=}$x$, {\tt y=$y$},
          {\tt l=$\ell$}, {\tt t=$\theta$}
          are scalars \\
	& {\tt d=}$d$ (an integer scalar $\ge 0$) \\
	& {\tt v=}$(v_x,v_y)$, {\tt w=}$(w_x,w_y)$ are vectors \\
then: \\[1ex]
\tt (x,y) & returns $(x,y)$ \\
\tt v==w:d & returns $v_x==w_x:d$ AND $v_y==w_y:d$ \\
\tt s*v & returns $(s v_x, s v_y )$ \\
\tt -v & returns $( -v_x, -v_y )$, {\tt v} with direction reversed \\
\tt v+w & returns $(v_x + w_x, v_y + w_y)$ \\
\tt v-w & returns $(v_x - w_x, v_y - w_y)$ \\
\tt ||v|| & returns $\sqrt{v_x^2 + v_y^2}$ & [length] \\
\tt azm v & returns $\mathrm{atan2}(v_y,v_x)$ & [azimuth] \\
\tt l\textasciicircum t
          & returns $(\ell\cos\theta,\ell\sin\theta)$, \\
	  & the vector with length {\tt l} and azimuth {\tt t} \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{rl}
Sample Input File: & \file{00-vector-vec-2d.sin} \\
Sample Output File: & \file{00-vector-vec-2d.sout} \\
or: & \file{00-vector-vec-2d.ftest} \\
Submit Run File: & \file{submit-vector-vec-2d.run} \\
\end{tabular}
\end{center}

Note that the {\tt .ftest} files for this problem are identical
to the corresponding {\tt .sout} files.

You can test your program using the indicated sample input and
output and you can submit your program using the indicated submit
run file.

\subsection{Vector Coding Hints}

You should write functions to do things like vector addition,
because later you will need to do these things in other
statements and will want a function to call.  Using the following
function signatures may make it easier
for other people familiar with this problem to read your
code, should that be important.

\hspace*{0.5in}\begin{minipage}{4.0in}
\begin{verbatim}
/* C Vector Function Signatures */
void printv ( vec );
vec addv ( vec v, vec w );
vec subv ( vec v, vec w );
vec negv ( vec v );
vec zerov = { 0, 0 };
double lenv ( vec v );
double azmv ( vec v );
vec polar ( double len, double azm );
\end{verbatim}
\end{minipage}

\bigskip

\hspace*{0.5in}\begin{minipage}{4.0in}
\begin{verbatim}
// C++ Vector Function Signatures
std::ostream & operator <<
        ( std::ostream & s, vec v );
vec operator + ( vec v, vec w );
vec operator - ( vec v, vec w );
vec operator - ( vec v );
vec zerov = { 0, 0 };
double len ( vec v );
double azm ( vec v );
vec polar ( double len, double azm );
\end{verbatim}
\end{minipage}

\section{Linear Transforms}
If we let $\mathcal{R}$ denote the set of real numbers,
a.k.a., scalars, the set of all vectors is \\
\centerline{
$\mathcal{R}\times\mathcal{R}=\mathcal{R}^2
    =\{(v_x,v_y)|v_x,v_y\in \mathcal{R}\}$}

\begin{definition}\label{LINEAR-TRANSFORMATION}
A \key{linear transformation} $L$ is a continuous map
$L:\mathcal{R}^2\mapsto\mathcal{R}^2$ such that for
all vectors $v$ and $w$, $L(v+w)=L(v)+L(w)$.
\end{definition}

Some examples of linear transformations are (1) the identity map,
(2) rotations, (3) reflections about an axis, (4) scale changes
(i.e., $(v_x,v_y)\longmapsto(s_x v_x,s_y v_y)$ for scalars $s_x$
and $s_y$).


\begin{lemma}
Let $L$ be a linear transformation, $v$ and $w$ be vectors,
and $0=(0,0)$ be the zero vector.  Then $L(0)=0$,  $L(-v)=-L(v)$,
and $L(v-w) = L(v) - L(w)$.
\end{lemma}
\begin{indpar}{0.5in}
Proof: $L(0) = L(0+0)= L(0) + L(0)$ so subtracting $L(0)$
from both sides, $0=L(0)$.  $0 = L(0) = L(v-v) = L(v) + L(-v)$
so subtracting $L(v)$ from both sides $-L(v)=L(-v)$.
$L(v-w)=L(v+(-w))=L(v)+L(-w)=L(v)+(-L(w))=L(v)-L(w)$.
\end{indpar}

\begin{lemma}
Let $L$ be a linear transformation, $s$ be a scalar, and $v$ be a vector.
Then $L(s*v)=s*L(v)$.
\end{lemma}
\begin{indpar}{0.5in}
Proof: The cases $s=0,1,2,-1,-2$ follow from the previous lemma and
using induction proves the lemma for any integer $s$.  For $s=n/d$
a rational number with integers $n$ and $d$ and $d>0$, \\
\hspace*{0.1in}$n*L(v) = L(n*(d/d)*v) = L(d*(n/d)*v)=d*L((n/d)*v)$ \\
so dividing by $d$
we get $L((n/d)*v)=(n/d)*L(v)$.  For $s$ a non-rational real number,
the result follows from a continuity argument that we will leave
to the mathematicians, since computer scientists only compute
with rational numbers.
\end{indpar}

Let $L$ be a linear transformation; let $v=(v_x,v_y)$ be a vector;
let $u_x=(1,0)$ and $u_y =(0,1)$.  Then \\
\centerline{$L(v) = L(v_x*u_x+v_y*u_y)=v_x*L(u_x)+v_y*L(u_y)$.}

\begin{lemma}
Given vectors $\ell_x$ and $\ell_y$, the map
$L:(v_x,v_y)\longmapsto v_x*\ell_x+v_y*\ell_y$ is a linear
transformation.
\end{lemma}
\begin{indpar}{0.5in}
Proof: $L(v+w) = (v_x+w_x)*\ell_x+(v_y+w_y)*\ell_y
               = v_x*\ell_x+v_y*\ell_y+w_x*\ell_x+w_y*\ell_y
	       = L(v) + L(w)$.
\end{indpar}

So $L$ is determined by $\ell_x = L(u_x)$ and $\ell_y = L(u_y)$,
and there is a 1-1 correspondence between linear transformations
and vector pairs $(\ell_x,\ell_y)$.  Therefore we will represent a linear
transformation $L$ by a pair of vectors {\tt ($\ell_x$,$\ell_y$)}
and represent application of L to the vector {\tt v = ($v_x$,$v_y$)} by \\
\centerline{\tt $L(v)$ = ($\ell_x$,$\ell_y$)*($v_x$,$v_y$) =
             $v_x$*$\ell_x$+$v_y$*$\ell_y$}

Examples:
\begin{enumerate}
\item {\tt L=((1,0),(0,1))} is the identity map.
$L(v)=v_x*(1,0) + v_y*(0,1) = (v_x,0)+(0,v_y) = (v_x,v_y) = v$.
\item {\tt L=((0,1),(-1,0))} rotates vectors $90^\circ$.
Specifically, $L(u_x)=u_y$ and $L(u_y)=-u_x$ and
$L(v)=v_x*(0,1) + v_y*(-1,0) = (0,v_x)+(-v_y,0) = (-v_y,v_x)$.
\item {\tt L=((-1,0),(0,-1))} reverses the direction of a vector.
$L(v)=v_x*(-1,0) + v_y*(0,-1) = (-v_x,0)+(0,-v_y) = (-v_x,-v_y) = -v$.
\item {\tt L=((-1,0),(0,1))} reflects vectors across the Y-axis.
$L(v)=v_x*(-1,0) + v_y*(0,1) = (-v_x,0)+(0,v_y) = (-v_x,v_y)$.
\item {\tt L=(($s_x$,0),(0,$s_y$))} scales the X-axis by $s_x$ and
the Y-axis by $s_y$. \\
$L(v)=v_x*(s_x,0) + v_y*(0,s_y)
     = (s_x v_x,0)+(0,s_y v_y)= (s_x v_x, s_y v_y)$.
\end{enumerate}

Now suppose we have a scalar {\tt s}, vector {\tt v},
and two linear transformations
{\tt K = ($\ell^K_x$,$\ell^K_y$)},
{\tt L = ($\ell^L_x$,$\ell^L_y$)}.  Then we can define:
\begin{center}
\tt
\begin{tabular}{l@{~so that~}l}
s*L = (s*$\ell^L_x$,s*$\ell^L_y$)
	 & (s*L)*v = s*(L*v) \\[0.3ex]
K+L = ($\ell^K_x$+$\ell^L_x$,$\ell^K_y$+$\ell^L_y$)
	 & (K+L)*v = K*v + L*v \\[0.3ex]
K+L = ($\ell^K_x$+$\ell^L_x$,$\ell^K_y$+$\ell^L_y$)
	 & (K+L)*v = K*v + L*v \\[0.3ex]
K-L = ($\ell^K_x$-$\ell^L_x$,$\ell^K_y$-$\ell^L_y$)
	 & (K-L)*v = K*v - L*v \\[0.3ex]
-L = (-$\ell^L_x$,-$\ell^L_y$)
	 & (-L)*v = - L*v \\[0.3ex]
K*L = (K*$\ell^L_x$,K*$\ell^L_y$)
	 & (K*L)*v = K*(L*v)
\end{tabular}
\end{center}

Note that {\tt *} and {\tt +} as defined here are bi-linear
(letting {\tt J} be another linear transformation):
\begin{center}
\tt
s*(K+L) = s*K + s*L \\
(J+K)*L = J*L + K*L \\
J*(K+L) = J*K + J*L
\end{center}

Also note that {\tt K*L} is in general \underline{not equal}
to {\tt L*K}.



\newpage

\section{Linear Transform Calculator}
Implement additions to the vector calculator for just {\em linear-transform}
value types and the {\em operators} and {\em functions}:
\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}
Assume: & {\tt s=}$s$ is a scalar \\
	& {\tt v=($v_x$,$v_y$)} and {\tt w=($w_x$,$w_y$)} are vectors \\
	& {\tt K=($\ell^K_x$,$\ell^K_y$)} and
	  {\tt L=($\ell^L_x$,$\ell^L_y$)} are linear transforms \\
then: \\[1ex]
\tt (v,w) & returns $(v,w)$ \\
\tt K==L:d & returns $\ell^K_x==\ell^L_x:d$ AND $\ell^K_y==\ell^L_y:d$ \\
\tt L*v & returns {\tt ($v_x\ell^L_x$,$v_y\ell^L_y$)} \\
\tt s*K & returns {\tt ($s\ell^L_x$,$s\ell^L_y$)} \\
\tt K+L & returns {\tt ($\ell^K_x$+$\ell^L_x$,$\ell^K_y$+$\ell^L_y$)} \\
\tt K-L & returns {\tt ($\ell^K_x$-$\ell^L_x$,$\ell^K_y$-$\ell^L_y$)} \\
\tt -L & returns {\tt (-$\ell^L_x$,-$\ell^L_y$)} \\
\tt K*L & returns {\tt (K*$\ell^L_x$,K*$\ell^L_y$)} \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{rl}
Sample Input File: & \file{00-linear-vec-2d.sin} \\
Sample Output File: & \file{00-linear-vec-2d.sout} \\
or: & \file{00-linear-vec-2d.ftest} \\
Submit Run File: & \file{submit-linear-vec-2d.run} \\
\end{tabular}
\end{center}

Note that the {\tt .ftest} files for this problem are identical
to the corresponding {\tt .sout} files.

You can test your program using the indicated sample input and
output and you can submit your program using the indicated submit
run file.

\newpage

\section{Rotations and Reflections}
Rotations and reflections are the two kinds of linear transformations
that preserve vector lengths (i.e., $||L(v)||=||v||$).

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}[5]{r}{0.4\textwidth}
\begin{tikzpicture}[x=0.20in,y=0.20in]
\begin{scope}[>=triangle 45,shorten >=0.01in]
    \draw[black] (-1,0) -- (+5,0);
    \draw[black] (0,-1) -- (0,+3);

    \fill[red] (0,0) circle(0.1);

    \draw[brown,>=latex,->] (2.0,0) arc(0:30:2.0);
    \draw[black] (3.2,+0.4) node{azm~$v$};

    \draw[blue,>=latex,->] (1.7320508,1.0) arc(30:150:2.0);
    \draw[black] (+0.5,+2.3) node{$\phi$};

    \fill[red] (3.464101615,2.0) circle(0.1);
    \draw[red,->] (0,0) -- (3.464101615,2.0);
    \draw[black] (3.6,2.6) node{$v$};

    \fill[red] (-3.464101615,2.0) circle(0.1);
    \draw[red,->] (0,0) -- (-3.464101615,2.0);
    \draw[black] (-3.6,+2.6) node{$R^\phi(v)$};

\end{scope}
\end{tikzpicture}
\end{wrapfigure}
A \key{rotation} $R^\phi$ by $\phi$ degrees (counter-\EOL clockwise)
is defined mathematically by
\hspace*{0.2in}\begin{tabular}[t]{l}
$||R^\phi(v)|| = ||v||$ \\
$\mathrm{azm}~R^\phi(v) = \mathrm{azm}~v + \phi$ \\
\end{tabular} \\
~\\
A rotation preserves angles between vectors; that is: \\
\hspace*{0.2in}$\mathrm{asm}~R^\phi(v)-\mathrm{asm}R^\phi(w)
               = \mathrm{asm}~v-\mathrm{asm}~w$ \\
Also, adding integer multiples of 360 to $\phi$
does \underline{not} change $R^\phi$.
\end{minipage}

\bigskip

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}[5]{r}{0.5\textwidth}
\begin{tikzpicture}[x=0.20in,y=0.20in]
\begin{scope}[>=triangle 45,shorten >=0.01in]
    \draw[black] (-1,0) -- (+1,0);
    \draw[black] (0,-1) -- (0,+1);

    \fill[red] (0,0) circle(0.1);

    \fill[red] (3.464101615,2.0) circle(0.1);
    \draw[red,->] (0,0) -- (3.464101615,2.0);
    \draw[black] (2.7,0.6) node{$v$};

    \fill[red] (4.0,4.0) circle(0.1);
    \draw[brown,->] (0,0) -- (4.0,4.0);
    \draw[black] (1.4,2.8) node{$v+w$};

    \draw[blue,->] (3.464101615,2.0) -- (4.0,4.0);
    \draw[black] (4.2,3.0) node{$w$};

    \fill[red] (-3.464101615,2.0) circle(0.1);
    \draw[red,->] (0,0) -- (-3.464101615,2.0);
    \draw[black] (-1.4,+2.0) node{$R^\phi(v)$};

    \fill[red] (-5.464101521,1.464101590) circle(0.1);
    \draw[brown,->] (0,0) -- (-5.464101521,1.464101590);
    \draw[black] (-4.2,+0.2) node{$R^\phi(v+w)$};

    \draw[blue,->] (-3.464101615,2.0) -- (-5.464101521,1.464101590);
    \draw[black] (-5.0,2.3) node{$R^\phi(w)$};

\end{scope}
\end{tikzpicture}
\end{wrapfigure}
A rotation perserves side-lengths and angles of a triangle.
Therefore, a rotation preserves vector addition, that is,
$R^\phi(v+w)=R^\phi(v)+R^\phi(w)$, and thus
satisfies Definition~\ref{LINEAR-TRANSFORMATION}
and is a linear transformation.
\end{minipage}

\bigskip

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}[6]{r}{0.4\textwidth}
\begin{tikzpicture}[x=0.20in,y=0.20in]
\begin{scope}[>=triangle 45,shorten >=0.01in]
    \draw[black] (-1,0) -- (+5,0);
    \draw[black] (0,-1) -- (0,+1);

    \fill[red] (0,0) circle(0.1);

    \draw[red] (-0.577350269,-1) -- (2.886751345,5);

    \draw[brown,>=latex,->] (4.0,0) arc(0:60:4.0);
    \draw[black] (3.6,2.6) node{$\phi$};

    \fill[red] (2.897777478,0.776457135) circle(0.1);
    \draw[red,->] (0,0) -- (2.897777478,0.776457135);
    \draw[black] (3.2,0.3) node{$v$};

    \fill[red] (-0.776457135,2.897777478) circle(0.1);
    \draw[red,->] (0,0) -- (-0.776457135,2.897777478);
    \draw[black] (-1.3,+3.6) node{$F^\phi(v)$};

    \draw[blue,>=latex,->] (1.0,1.732050807) arc(60:15:2.0);
    \draw[black] (2.0,1.5) node{$\alpha$};

    \draw[blue] (1.0,1.732050807) circle(0.1);

    \draw[blue,>=latex,->] (1.0,1.732050807) arc(60:105:2.0);
    \draw[black] (0.3,2.3) node{$-\alpha$};

\end{scope}
\end{tikzpicture}
\end{wrapfigure}
A \key{reflection} $F^\phi$ by $\phi$ degrees
is a reflection accross the line through the origin with
direction $\phi$ and
is defined mathematically by
\hspace*{0.2in}\begin{tabular}[t]{l}
$||R^\phi(v)|| = ||v||$ \\
$\mathrm{azm}~F^\phi(v) = \phi - \alpha$ \\
where $\alpha = \mathrm{azm}~v - \phi$ so \\
$\mathrm{azm}~F^\phi(v) = 2*\phi - \mathrm{azm}~v$ \\
\end{tabular} \\
~\\
A reflection negates angles between vectors; that is: \\
\hspace*{0.2in}$\mathrm{asm}~F^\phi(v)-\mathrm{asm}F^\phi(w)
               = -(\mathrm{asm}~v-\mathrm{asm}~w)$ \\
Also, adding integer multiples of 180 to $\phi$
does \underline{not} change $F^\phi$.
\end{minipage}

\bigskip

\begin{minipage}{\textwidth}\raggedright
\begin{wrapfigure}[7]{r}{0.5\textwidth}
\begin{tikzpicture}[x=0.25in,y=0.25in]
\begin{scope}[>=triangle 45,shorten >=0.01in]
    \draw[black] (-1,0) -- (+1,0);
    \draw[black] (0,-1) -- (0,+1);

    \fill[red] (0,0) circle(0.1);

    \draw[red] (-0.577350269,-1) -- (2.5,4.330127018);

    \fill[red] (2.897777478,0.776457135) circle(0.1);
    \draw[red,->] (0,0) -- (2.897777478,0.776457135);
    \draw[black] (1.5,0.8) node{$v$};

    \draw[blue,->] (2.897777478,0.776457135) -- (3.863703305,-1.035276180);
    \draw[black] (3.8,-0.0) node{$w$};

    \fill[red] (3.863703305,-1.035276180) circle(0.1);
    \draw[brown,->] (0,0) -- (3.863703305,-1.035276180);
    \draw[black] (2.0,-1.2) node{$v+w$};

    \fill[red] (-0.776457135,2.897777478) circle(0.1);
    \draw[red,->] (0,0) -- (-0.776457135,2.897777478);
    \draw[black] (+0.4,+2.6) node{$F^\phi(v)$};

    \draw[blue,->] (-0.776457135,2.897777478) -- (-2.828427124,2.828427124);
    \draw[black] (-1.8,+3.5) node{$F^\phi(w)$};

    \fill[red] (-2.828427124,2.828427124) circle(0.1);
    \draw[brown,->] (0,0) -- (-2.828427124,2.828427124);
    \draw[black] (-3.0,+1.0) node{$F^\phi(v+w)$};

\end{scope}
\end{tikzpicture}
\end{wrapfigure}
A reflection perserves side-lengths and negates angles of a triangle.
Therefore, a reflection preserves vector addition, that is,
$F^\phi(v+w)=F^\phi(v)+F^\phi(w)$, and thus
satisfies Definition~\ref{LINEAR-TRANSFORMATION}
and is a linear transformation.
\end{minipage}

\vspace{0.5in}

A linear map $L$ that preserves vector lengths ($||L(v)||=||v||$)
is said to be \key{unitary}.
A unitary linear map $L$
also preserves the absolute values of angles between vectors,
because $L$ preserves the side-lengths of any triangle made of
vectors, and these determine the absolute values of the angles of
the triangle (but not the direction of these angles).  Now
$L$ being linear is determined by $L(u_x)$ and $L(u_y)$, where
$u_x=(1,0)$ and $u_y=(0,1)$, and as $u_y$ is perpendicular to
$u_x$, $L(u_y)$ must be perpendicular to $L(u_x)$ if $L$ is unitary.
So for unitary $L$, in 2 dimensions there are only two possibilities
for $L(u_y)$ given $L(u_x)$.


$u_y$ is $u_x$ rotated counter-clockwise by 90 degrees.
If for unitary $L$, $L(u_y)$ is $L(u_x)$ rotated counter-clockwise
by 90 degrees, $L$ is a rotation.
But if $L(u_y)$ is $L(u_x)$ rotated clockwise
by 90 degrees, $L$ is a reflection.  All unitary linear transformations
in 2 dimensions must be either rotations or reflections.

If $L$ is a rotation, the angle of rotation is: \\
\centerline{$\phi = \mathrm{asm}~L(u_x) - \mathrm{asm}~u_x =
             \mathrm{asm}~L(u_x)$}
and we have: \begin{tabular}[t]{l}
             $L(u_x)=(\cos\phi,\sin\phi)$ \\
             $L(u_y)=(-\sin\phi,\cos\phi)$ \\
	     \end{tabular}

If $L$ is a reflection, the angle of the reflecting line is: \\
\centerline{$\phi = (1/2)*(\mathrm{asm}~L(u_x) + \mathrm{asm}~u_x)$}
In order to calculate $L(u_x)$ from $\phi$ without using polar
coordinates we need the notion of scalar product, developed in a
following section.

Both rotations and reflections preserve vector lengths
and change vector angles according to a linear formula.
Using the notation $R^\phi$ for rotation by angle $\phi$,
and $F^\phi$ for reflection about the line at angle $\phi$,
we get the following:
\begin{center}
$R^\phi*R^\omega=R^\omega*R^\phi=R^{\phi+\omega}$
~~because~~
    $(\mathrm{azm}~v + \omega) + \phi = \mathrm{azm}~v + (\phi+\omega)$ \\
$F^\phi*F^\omega = R^{2(\phi-\omega)}$
~~because~~
    $2\phi - (2\omega - \mathrm{azm}~v) = \mathrm{azm}~v + 2(\phi-\omega)$
\end{center}
Note that while $R^\phi*R^\omega=R^\omega*R^\phi$,
$F^\omega*F^\phi$ is the inverse rotation of $F^\phi*F^\omega$.

\bigskip

\section{Unitary Transform Calculator}
Implement additions to the linear calculator for
the {\em operators} and {\em functions}:
\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}
\multicolumn{2}{l}{Assume:} \\
        & {\tt p=}$p$ is a scalar \\
	& {\tt v} is a vector \\
then: \\[1ex]
\tt v\textasciicircum p & return {\tt w} such that {\tt ||w||=||v||} and
	                  {\tt asm w = asm v + p}, \\
			& {\tt v} rotated by {\tt p} degrees \\
\tt v|p & return {\tt w} such that {\tt ||w||=||v||} and
	                  {\tt asm w = 2*p\,-\,asm v}, \\
			& {\tt v} reflected across the line with direction
			  {\tt p} degrees \\
\tt \textasciicircum p
       & return {\tt ($u_x$\textasciicircum p,$u_y$\textasciicircum p)}, \\
       & the rotation $R^p$ with angle $p$ degrees \\
\tt |p & return {\tt ($u_x$|p,$u_y$|p)}, \\
       & the reflection $F^p$ across the line with direction $p$ degrees \\
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{rl}
Sample Input File: & \file{00-unitary-vec-2d.sin} \\
Sample Output File: & \file{00-unitary-vec-2d.sout} \\
or: & \file{00-unitary-vec-2d.ftest} \\
Submit Run File: & \file{submit-unitary-vec-2d.run} \\
\end{tabular}
\end{center}

Note that the {\tt .ftest} files for this problem are identical
to the corresponding {\tt .sout} files.

You can test your program using the indicated sample input and
output and you can submit your program using the indicated submit
run file.

\newpage

\section{Products}
There are two products of a pair of vectors that play a
very important role in 2D computational geometry:

\begin{definition}
The \key{scalar product} of two vectors \\
\centerline{{\tt v = ($v_x$,$v_y$)} and {\tt w = ($w_x$,$w_y$)}} \\
is \\
\centerline{\tt v*w = $v_x w_x + v_y w_y$} \\
The \key{cross product} of the two vectors is \\
\centerline{\tt v\#w = $(-v_y)w_x + v_x w_y$}
\end{definition}

Note that {\tt ||v||$^2$ = v*v}.

If we denote the vector {\tt v} rotated counter-clockwise by
{\tt p} degrees by {\tt v\textasciicircum p}.  Then \\
\centerline{\tt v\#w = (p\textasciicircum 90)*w}

Both the scalar and cross product are \key{bi-linear}.  That is,
if {\tt u}, {\tt v}, {\tt w} are vectors and {\tt s} is a scalar:
\begin{center}
\tt
(u+v)*w = u*w + v*w \\
u*(v+w) = u*v + u*w \\
(s*u)*w = s*(u*w) = u*(s*w) \\
(u+v)\#w = u\#w + v\#w \\
u\#(v+w) = u\#v + u\#w \\
(s*u)\#w = s*(u\#w) = u\#(s*w)
\end{center}

Note that the scalar product is symmetric ({\tt v*w = w*v})
while the cross product is anti-symmetric ({\tt v\#w = -w\#v}).

\begin{lemma}
For a unitary transform {\tt L}:
\begin{enumerate}
\item {\tt L(v)*L(w) = v*w} for all vectors {\tt v} and {\tt w}.
\item If {\tt L} is a rotation,
         {\tt L(v)\#L(w) = v\#w} for all vectors {\tt v} and {\tt w}; \\
      if {\tt L} is a reflection,
         {\tt L(v)\#L(w) = - v\#w} for all vectors {\tt v} and {\tt w}.
\end{enumerate}
\end{lemma}

\section{Product Calculator}
Implement additions to the unitary calculator for
the following {\em operators} and {\em functions}:
\begin{center}
\begin{tabular}{l@{~~~~~}l@{~~~~~}l}
Assume: & {\tt d=}$d$ (a scalar) \\
	& {\tt v=}$(v_x,v_y)$ (a vector) \\
	& {\tt w=}$(w_x,w_y)$ (a vector) \\
then: \\[1ex]
\tt v*w & returns $v_x w_x + w_y w_y$,
          the scalar product of {\tt v} and {\tt w} \\
\tt v\#w & returns $(-v_y)w_x+v_x w_y$,
           the cross product of {\tt v} and {\tt w} \\
TBD
\end{tabular}
\end{center}

\begin{center}
\begin{tabular}{rl}
Sample Input File: & \file{00-product-vec-2d.sin} \\
Sample Output File: & \file{00-product-vec-2d.sout} \\
or: & \file{00-product-vec-2d.ftest} \\
Submit Run File: & \file{submit-product-vec-2d.run} \\
\end{tabular}
\end{center}

Note that the {\tt .ftest} files for this problem are identical
to the corresponding {\tt .sout} files.

You can test your program using the indicated sample input and
output and you can submit your program using the indicated submit
run file.


\bigskip

\begin{tabular}{ll}
Author:	      & Robert L.~Walton $<$walton@acm.org$>$ \\
Date:         & Tue Oct 20 15:52:22 EDT 2020
\end{tabular}

The authors have placed this problem in the public domain;
they make no warranty and accept no liability for this problem.

\end{document}
